<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Stact</name>
    </assembly>
    <members>
        <member name="T:Stact.Actor">
            <summary>
            Declares the class is an actor. This is a marker interface.
            </summary>
        </member>
        <member name="M:Stact.ActorConvention`1.Matches(Stact.ActorConvention{`0})">
            <summary>
            Determines if a convention the same as the target convention, to avoid 
            duplicate conventions from being added
            </summary>
            <param name="convention">The convention to compare</param>
            <returns>True if it matches, otherwise false</returns>
        </member>
        <member name="T:Stact.ActorInstance">
            <summary>
            An ActorInstance is used to send messages to an actor instance. This abstraction
            helps avoid tight coupling with the actor class definition.
            </summary>
        </member>
        <member name="T:Stact.UntypedChannel">
            <summary>
            A channel to which any message type can be sent
            </summary>
        </member>
        <member name="T:Stact.Channel">
            <summary>
            The base Channel interface, used as a marker to identify channels
            </summary>
        </member>
        <member name="M:Stact.UntypedChannel.Send``1(``0)">
            <summary>
              Send a message to an untyped channel
            </summary>
            <typeparam name = "T">The message type</typeparam>
            <param name = "message">The message</param>
        </member>
        <member name="T:Stact.ActorFactory`1">
            <summary>
            A builder abstraction for creating actor instances when needed
            </summary>
            <typeparam name="TActor">The actor type</typeparam>
        </member>
        <member name="M:Stact.ActorFactory`1.GetActor">
            <summary>
            Returns an instance of an actor
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stact.ExtensionsForLinking.Link(Stact.ActorInstance,Stact.Inbox)">
            <summary>
            Initiates a link to another actor instance. Once linked, if either actor
            exits, all actors linked to this actor will be sent an Exit with a reason
            of actor death
            </summary>
            <param name="actor">The actor to link</param>
            <param name="inbox">The inbox of the actor requesting the link</param>
        </member>
        <member name="T:Stact.UntypedFilterChannel`1">
            <summary>
            This is a type of siphon filter that would remove a message from an untyped
            channel rather than passing it to the output channel. It is mainly designed for handling
            intercept messages such as a Kill command to an actor.
            </summary>
            <typeparam name="TOutput">The message type to siphon from the channel</typeparam>
        </member>
        <member name="T:Stact.Internal.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
        </member>
        <member name="M:Stact.Internal.LocalizationRequiredAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Stact.Internal.LocalizationRequiredAttribute"/> class.
            </summary>
            <param name="required"><c>true</c> if a element should be localized; otherwise, <c>false</c>.</param>
        </member>
        <member name="M:Stact.Internal.LocalizationRequiredAttribute.Equals(System.Object)">
            <summary>
            Returns whether the value of the given object is equal to the current <see cref="T:Stact.Internal.LocalizationRequiredAttribute"/>.
            </summary>
            <param name="obj">The object to test the value equality of. </param>
            <returns>
            <c>true</c> if the value of the given object is equal to that of the current; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Stact.Internal.LocalizationRequiredAttribute.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A hash code for the current <see cref="T:Stact.Internal.LocalizationRequiredAttribute"/>.</returns>
        </member>
        <member name="P:Stact.Internal.LocalizationRequiredAttribute.Required">
            <summary>
            Gets a value indicating whether a element should be localized.
            <value><c>true</c> if a element should be localized; otherwise, <c>false</c>.</value>
            </summary>
        </member>
        <member name="T:Stact.Internal.StringFormatMethodAttribute">
            <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> -like form
            </summary>
        </member>
        <member name="M:Stact.Internal.StringFormatMethodAttribute.#ctor(System.String)">
            <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
            <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
        </member>
        <member name="P:Stact.Internal.StringFormatMethodAttribute.FormatParameterName">
            <summary>
            Gets format parameter name
            </summary>
        </member>
        <member name="T:Stact.Internal.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException"/> has such parameter.
            </summary>
        </member>
        <member name="T:Stact.Internal.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:Stact.Internal.AssertionConditionAttribute"/> attribute
            </summary>
            <seealso cref="T:Stact.Internal.AssertionConditionAttribute"/>
        </member>
        <member name="T:Stact.Internal.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:Stact.Internal.AssertionMethodAttribute"/> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
            <seealso cref="T:Stact.Internal.AssertionConditionType"/>
        </member>
        <member name="M:Stact.Internal.AssertionConditionAttribute.#ctor(Stact.Internal.AssertionConditionType)">
            <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
            <param name="conditionType">Specifies condition type</param>
        </member>
        <member name="P:Stact.Internal.AssertionConditionAttribute.ConditionType">
            <summary>
            Gets condition type
            </summary>
        </member>
        <member name="T:Stact.Internal.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
        </member>
        <member name="F:Stact.Internal.AssertionConditionType.IS_TRUE">
            <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
        </member>
        <member name="F:Stact.Internal.AssertionConditionType.IS_FALSE">
            <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
        </member>
        <member name="F:Stact.Internal.AssertionConditionType.IS_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
        </member>
        <member name="F:Stact.Internal.AssertionConditionType.IS_NOT_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
        </member>
        <member name="T:Stact.Internal.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception
            </summary>
        </member>
        <member name="T:Stact.Internal.CanBeNullAttribute">
            <summary>
            Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage
            </summary>
        </member>
        <member name="T:Stact.Internal.NotNullAttribute">
            <summary>
            Indicates that the value of marked element could never be <c>null</c>
            </summary>
        </member>
        <member name="T:Stact.Internal.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of marked type (or its derivatives) cannot be compared using '==' or '!=' operators.
            There is only exception to compare with <c>null</c>, it is permitted
            </summary>
        </member>
        <member name="T:Stact.Internal.BaseTypeRequiredAttribute">
            <summary>
            When applied to target attribute, specifies a requirement for any type which is marked with 
            target attribute to implement or inherit specific type or types
            </summary>
            <example>
            <code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute 
            {}
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent
            {}
            </code>
            </example>
        </member>
        <member name="M:Stact.Internal.BaseTypeRequiredAttribute.#ctor(System.Type[])">
            <summary>
            Initializes new instance of BaseTypeRequiredAttribute
            </summary>
            <param name="baseTypes">Specifies which types are required</param>
        </member>
        <member name="P:Stact.Internal.BaseTypeRequiredAttribute.BaseTypes">
            <summary>
            Gets enumerations of specified base types
            </summary>
        </member>
        <member name="T:Stact.Internal.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="P:Stact.Internal.UsedImplicitlyAttribute.TargetFlags">
            <summary>
            Gets value indicating what is meant to be used
            </summary>
        </member>
        <member name="T:Stact.Internal.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="P:Stact.Internal.MeansImplicitUseAttribute.TargetFlags">
            <summary>
            Gets value indicating what is meant to be used
            </summary>
        </member>
        <member name="F:Stact.Internal.ImplicitUseKindFlags.Access">
            <summary>
            Only entity marked with attribute considered used
            </summary>
        </member>
        <member name="F:Stact.Internal.ImplicitUseKindFlags.Assign">
            <summary>
            Indicates implicit assignment to a member
            </summary>
        </member>
        <member name="F:Stact.Internal.ImplicitUseKindFlags.Instantiated">
            <summary>
            Indicates implicit instantiation of a type
            </summary>
        </member>
        <member name="T:Stact.Internal.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked with <see cref="T:Stact.Internal.MeansImplicitUseAttribute"/> or <see cref="T:Stact.Internal.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:Stact.Internal.ImplicitUseTargetFlags.Members">
            <summary>
            Members of entity marked with attribute are considered used
            </summary>
        </member>
        <member name="F:Stact.Internal.ImplicitUseTargetFlags.WithMembers">
            <summary>
            Entity marked with attribute and all its members considered used
            </summary>
        </member>
        <member name="P:Stact.SetMessageHeader.MessageId">
            <summary>
            The identifier for this message
            </summary>
        </member>
        <member name="P:Stact.SetMessageHeader.CorrelationId">
            <summary>
            The identifier correlating this message to a message exchange/conversation
            </summary>
        </member>
        <member name="P:Stact.SetMessageHeader.SenderAddress">
            <summary>
            The sender address of the message
            </summary>
        </member>
        <member name="P:Stact.SetMessageHeader.DestinationAddress">
            <summary>
            The final destination of the message
            </summary>
        </member>
        <member name="P:Stact.SetMessageHeader.FaultAddress">
            <summary>
            The address where faults should be sent
            </summary>
        </member>
        <member name="T:Stact.ActorRegistry">
            <summary>
            An actor registry provide running storage for actors that are active in the system
            </summary>
        </member>
        <member name="M:Stact.ActorRegistry.Register(System.Guid,Stact.ActorInstance)">
            <summary>
            Adds an actor instance to the registry
            </summary>
            <param name="key">The unique identifier for the actor instance</param>
            <param name="actor">The actor instance</param>
        </member>
        <member name="M:Stact.ActorRegistry.Register(Stact.ActorInstance,System.Action{System.Guid,Stact.ActorInstance})">
            <summary>
            Adds an actor to the registry
            </summary>
            <param name="actor">The actor to add</param>
            <param name="callback"></param>
        </member>
        <member name="M:Stact.ActorRegistry.Unregister(Stact.ActorInstance)">
            <summary>
            Removes an actor from the registry
            </summary>
            <typeparam name="T">The type of the actor</typeparam>
            <param name="actor">The actor to remove</param>
        </member>
        <member name="M:Stact.ActorRegistry.Unregister(System.Guid)">
            <summary>
            Removes an actor from the registry
            </summary>
            <param name="key">The id of the actor to remove</param>
        </member>
        <member name="M:Stact.ActorRegistry.Shutdown">
            <summary>
            Stops all actors and removes them from the registry
            </summary>
        </member>
        <member name="M:Stact.ActorRegistry.Get(System.Guid,System.Action{Stact.ActorInstance},System.Action)">
            <summary>
            Gets an actor from the registry
            </summary>
            <param name="key">The id of the actor</param>
            <param name="callback"></param>
            <param name="notFoundCallback"></param>
        </member>
        <member name="M:Stact.ActorRegistry.Select(System.Uri,System.Action{Stact.ActorInstance},System.Action)">
            <summary>
            Returns an actor instance for the actor referenced by the URI specified.
            </summary>
            <param name="actorAddress">The URI for the actor, maybe be a local or remote actor address</param>
            <param name="callback">Called when the actor intance is available</param>
            <param name="notFoundCallback">Called if the actor instance was not found and could not be created</param>
        </member>
        <member name="M:Stact.ActorRegistry.Each(System.Action{System.Guid,Stact.ActorInstance})">
            <summary>
            Calls the callback for each actor in the registry
            </summary>
            <param name="callback">A method to call with each actor</param>
        </member>
        <member name="M:Stact.ActorRegistry.Subscribe(System.Action{Stact.Configuration.ConnectionConfigurator})">
            <summary>
            Allow subscription to events that are produced by the actor registry as actors
            are registered and unregistered.
            </summary>
            <param name="subscriberActions">The subscription actions</param>
            <returns>A channel subscription</returns>
        </member>
        <member name="M:Stact.Configuration.ActorFactoryConfigurator`1.AddConvention(Stact.ActorConvention{`0})">
            <summary>
            Add conventions to apply to actor instances as they are created
            </summary>
            <param name="convention">The convention to apply to the actor instance</param>
            <returns>The configurator</returns>
        </member>
        <member name="T:Stact.Configuration.FiberFactoryConfigurator`1">
            <summary>
              Configures the type of fiber to be used for handling messages
            </summary>
            <typeparam name = "T"></typeparam>
        </member>
        <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.HandleOnCallingThread">
            <summary>
              Handle on the calling thread (synchronously)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.HandleOnPoolFiber">
            <summary>
              Handle on a dedicated fiber (uses the thread pool, lightweight)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.HandleOnFiber(Stact.Fiber)">
            <summary>
              Handle on the specified fiber
            </summary>
            <param name = "fiber">The fiber to use</param>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.HandleOnThreadFiber">
            <summary>
              Handle on a dedicated thread (operating system thread)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.UseFiberFactory(Stact.FiberFactory)">
            <summary>
              Use the specified fiber factory
            </summary>
            <param name = "fiberFactory">The fiber factory to use</param>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.UseFiberFactory(Stact.FiberFactoryEx)">
            <summary>
              Use the specified fiber factory
            </summary>
            <param name = "fiberFactory">The fiber factory to use</param>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.UseShutdownTimeout(System.TimeSpan)">
            <summary>
              Configure the shutdown timeout for the fiber
            </summary>
            <param name = "timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberFactoryConfigurator`1.UseBasicExecutor">
            <summary>
            Specifies the basic operation executor for the fiber, relying on operations
            to catch their own exceptions
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.Configurator.ValidateConfiguration">
            <summary>
            Validate the configuration, throwing an exception if the configuration settings
            are insufficient or invalid based on the type of configuration being performed.
            </summary>
        </member>
        <member name="T:Stact.Configuration.Internal.PropertyChannelConvention`2">
            <summary>
            Connects an actor property that implements Channel&lt;T&gt; to the inbox
            </summary>
            <typeparam name="TActor">The actor type</typeparam>
            <typeparam name="TChannel">The channel type</typeparam>
        </member>
        <member name="M:Stact.ExtensionsForActorConventions.ConnectPublicMethods``1(Stact.Configuration.ActorFactoryConfigurator{``0})">
            <summary>
            Connect methods that are public and have a single parameter that is a Message type, such as
            Message, Request, or Response as a consumer on the inbox
            </summary>
            <typeparam name="TActor"></typeparam>
            <param name="configurator"></param>
        </member>
        <member name="M:Stact.ExtensionsForActorConventions.ConnectPropertyChannels``1(Stact.Configuration.ActorFactoryConfigurator{``0})">
            <summary>
            Connect properties that are public and of type Channel&lt;T&gt; to the inbox
            </summary>
            <typeparam name="TActor"></typeparam>
            <param name="configurator"></param>
        </member>
        <member name="T:Stact.AnonymousActor">
            <summary>
            An anonymous actor is used to declare behavior inline, rather than using a 
            class. 
            </summary>
        </member>
        <member name="T:Stact.Internal.CreateChannelConnection">
            <summary>
            Allows channels and disposable items to be added to the connection
            </summary>
        </member>
        <member name="M:Stact.Internal.CreateChannelConnection.AddChannel(Stact.Channel)">
            <summary>
            Adds a channel to the connection
            </summary>
            <param name="channel"></param>
        </member>
        <member name="M:Stact.Internal.CreateChannelConnection.AddDisposable(System.IDisposable)">
            <summary>
            Adds a disposable reference to the connection
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="T:Stact.ChannelConnection">
            <summary>
            Contains the changes made by a connection to a channel so that they can be 
            removed when the connections are no longer required.
            </summary>
        </member>
        <member name="M:Stact.ChannelConnection.Disconnect">
            <summary>
            Disconnects any channels and/or consumers that were added by a Connect
            to a channel.
            </summary>
        </member>
        <member name="T:Stact.Configuration.ConnectionConfigurator`1">
            <summary>
            Used to configure the connections to be added to a typed Channel
            </summary>
            <typeparam name="TChannel">The channel type</typeparam>
        </member>
        <member name="M:Stact.Extensions.Exit(Stact.UntypedChannel)">
            <summary>
              Sends an Exit message to an actor instance without waiting for a response
            </summary>
            <param name = "instance">The actor instance</param>
        </member>
        <member name="M:Stact.Extensions.Exit(Stact.ActorInstance,Stact.Inbox)">
            <summary>
              Sends an Exit message to an actor instance
            </summary>
            <param name = "instance">The actor instance</param>
            <param name = "sender">The exit request sender</param>
        </member>
        <member name="M:Stact.Extensions.Kill(Stact.UntypedChannel)">
            <summary>
              Sends a Kill message to an actor instance
            </summary>
            <param name = "instance">The actor instance</param>
        </member>
        <member name="T:Stact.Internal.ActorChannelProvider`2">
            <summary>
              Provides a channel from an actor, based on the property information which is used
              to create a dynamic method that returns the actual channel
            </summary>
            <typeparam name = "TActor">The actor type</typeparam>
            <typeparam name = "TChannel">The channel type</typeparam>
        </member>
        <member name="T:Stact.ChannelProvider`1">
            <summary>
            Used by dispatching channels to retrieve the appropriate channel for
            a message.
            </summary>
            <typeparam name="T">The channel type</typeparam>
        </member>
        <member name="M:Stact.ChannelProvider`1.GetChannel(`0)">
            <summary>
            Get a channel for the message
            </summary>
            <param name="message">The message to use to select the channel</param>
            <returns>The channel that should process the message, or null</returns>
        </member>
        <member name="T:Stact.MessageHeaders.MatchHeaderCallback`1">
            <summary>
            Matches the header type and carries along a context value with the match
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="P:Stact.MessageHeader.BodyType">
            <summary>
            The message body type in URN-format
            </summary>
        </member>
        <member name="P:Stact.MessageHeader.MessageId">
            <summary>
            The identifier for this message
            </summary>
        </member>
        <member name="P:Stact.MessageHeader.CorrelationId">
            <summary>
            The identifier correlating this message to a message exchange/conversation
            </summary>
        </member>
        <member name="P:Stact.MessageHeader.SenderAddress">
            <summary>
            The sender address of the message
            </summary>
        </member>
        <member name="P:Stact.MessageHeader.DestinationAddress">
            <summary>
            The final destination of the message
            </summary>
        </member>
        <member name="P:Stact.MessageHeader.FaultAddress">
            <summary>
            The address where faults should be sent
            </summary>
        </member>
        <member name="P:Stact.MessageHeader.Headers">
            <summary>
            A general headers collection
            </summary>
        </member>
        <member name="P:Stact.RequestHeader.RequestId">
            <summary>
              The request identifier which should be returned with a response
            </summary>
        </member>
        <member name="P:Stact.RequestHeader.ResponseAddress">
            <summary>
              The address where a response should be sent (use the response channel, however)
            </summary>
        </member>
        <member name="P:Stact.ResponseHeader.RequestId">
            <summary>
              The request identifier which should be returned with a response
            </summary>
        </member>
        <member name="T:Stact.Channel`1">
            <summary>
            A one-way communication containing messages of the specified type
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Stact.Channel`1.Send(`0)">
            <summary>
            Send a message to the channel
            </summary>
            <param name="message">The message to send</param>
        </member>
        <member name="T:Stact.Remote.ReliableMulticast.ReliableMulticastWriter">
            <summary>
            Sends messages via Pragmatic General Multicast
            </summary>
        </member>
        <member name="T:Stact.Remote.RemoteActor">
            <summary>
            A reference to a remote actor
            
            Forwards messages to the remote actor using the header channel specified in the constructor.
            </summary>
        </member>
        <member name="M:Stact.RequestExtensions.Request``1(Stact.UntypedChannel,``0,Stact.UntypedChannel)">
            <summary>
              Wraps the message in a request and sends it to the channel
            </summary>
            <typeparam name = "TRequest">The type of the request message</typeparam>
            <param name = "channel">The channel where the message should be sent</param>
            <param name = "request">The request message</param>
            <param name = "responseChannel">The channel where responses should be sent</param>
        </member>
        <member name="M:Stact.RequestExtensions.Request``1(Stact.Channel{Stact.Request{``0}},``0,Stact.UntypedChannel)">
            <summary>
              Wraps the message in a request and sends it to the channel
            </summary>
            <typeparam name = "TRequest">The type of the request message</typeparam>
            <param name = "channel">The channel where the message should be sent</param>
            <param name = "request">The request message</param>
            <param name = "responseChannel">The channel where responses should be sent</param>
        </member>
        <member name="M:Stact.RequestExtensions.Request``1(Stact.UntypedChannel,Stact.UntypedChannel)">
            <summary>
              Sends an uninitialized interface implementation as a request
            </summary>
            <typeparam name = "TRequest">The request message type, which must be an interface</typeparam>
            <param name = "channel">The target channel</param>
            <param name = "responseChannel">The channel where responses should be sent</param>
        </member>
        <member name="M:Stact.RequestExtensions.Request``1(Stact.Channel{Stact.Request{``0}},Stact.UntypedChannel)">
            <summary>
              Sends an uninitialized interface implementation as a request
            </summary>
            <typeparam name = "TRequest">The request message type, which must be an interface</typeparam>
            <param name = "channel">The target channel</param>
            <param name = "responseChannel">The channel where responses should be sent</param>
        </member>
        <member name="M:Stact.RequestExtensions.Request``1(Stact.UntypedChannel,``0,Stact.Inbox)">
            <summary>
              Wraps the message in a request and sends it to the channel
            </summary>
            <typeparam name = "TRequest">The type of the request message</typeparam>
            <param name = "channel">The channel where the message should be sent</param>
            <param name = "request">The request message</param>
            <param name = "inbox">The response inbox</param>
        </member>
        <member name="M:Stact.RespondExtensions.Respond``2(Stact.Request{``0},``1)">
            <summary>
              Wraps a message in a response and sends it to the response channel of the request
            </summary>
            <typeparam name = "TRequest">The type of the request message</typeparam>
            <typeparam name = "TResponse">The type of the response message</typeparam>
            <param name = "request">The request context</param>
            <param name = "response">The response message</param>
        </member>
        <member name="T:Stact.Routing.Activation`1">
            <summary>
            An Activation moves a message from left to right in the graph, forward-chained
            to the next node.
            </summary>
            <typeparam name="T">The message type</typeparam>
        </member>
        <member name="T:Stact.Message`1">
            <summary>
            The message header, generic matching the type of the message body
            </summary>
            <typeparam name="T">The message body type</typeparam>
        </member>
        <member name="T:Stact.Message">
            <summary>
            The base message header, non-generic to allow use in any method
            </summary>
        </member>
        <member name="M:Stact.Routing.RoutingContext`1.Match(System.Action{Stact.Routing.RoutingContext{Stact.Message{`0}}},System.Action{Stact.Routing.RoutingContext{Stact.Request{`0}}},System.Action{Stact.Routing.RoutingContext{Stact.Response{`0}}})">
            <summary>
            Matches the message header type an invokes the proper callback
            </summary>
            <param name="messageCallback"></param>
            <param name="requestCallback"></param>
            <param name="responseCallback"></param>
        </member>
        <member name="P:Stact.Routing.RoutingContext`1.Priority">
            <summary>
            as types are abstracted, proxied, etc. the priority value decreases
            </summary>
        </member>
        <member name="T:Stact.Request`1">
            <summary>
            Request is a message stereotype that is applied to a message in which
            a response is expected
            </summary>
            <typeparam name = "T">The message type</typeparam>
        </member>
        <member name="P:Stact.Request`1.ResponseChannel">
            <summary>
              Where responses to the request should be sent
            </summary>
        </member>
        <member name="T:Stact.Response`1">
            <summary>
            Response is a message stereotype applied to a message that is in response
            to a Request message.
            </summary>
            <typeparam name="T">The message type</typeparam>
        </member>
        <member name="T:Stact.Routing.Nodes.ActiveContextList`1">
            <summary>
            An AlphaMemory retains a list of messages and automatically removes
            messages from the list when they are evicted from memory based on the
            context property IsAvailable
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Stact.Routing.Nodes.BetaMemory`1">
            <summary>
            A beta channel supports activation via a typed input and activates
            any successors upon receipt
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Stact.Routing.Nodes.RightActivation`1">
            <summary>
            A RightActivation moves a message along the right side of the graph, which is
            referred to as the beta network or join network.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Stact.Routing.Nodes.RightActivation`1.RightActivate(System.Func{Stact.Routing.RoutingContext{`0},System.Boolean})">
            <summary>
            Performs a join operation between the two messages, performing the callback for
            every activation on the right node until the callback returns false
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:Stact.Routing.Nodes.RightActivation`1.RightActivate(Stact.Routing.RoutingContext{`0},System.Action{Stact.Routing.RoutingContext{`0}})">
            <summary>
            Performs a match operation between two activations, 
            </summary>
            <param name="context"></param>
            <param name="callback"></param>
        </member>
        <member name="T:Stact.Routing.Nodes.ConstantNode`1">
            <summary>
            Always invokes on right activation for joining single alpha nodes
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Stact.Routing.Nodes.ConsumerNode`1">
            <summary>
            Delivers a message to a consumer on the specified fiber.
            </summary>
            <typeparam name="T">The message type</typeparam>
        </member>
        <member name="T:Stact.Routing.Nodes.ProductionNode`1">
            <summary>
            The basic functionality of a production node that deals with
            evicting the message from the routing engine and dispatching it
            to the specified delegate
            </summary>
            <typeparam name="T">The message type</typeparam>
        </member>
        <member name="T:Stact.Routing.Nodes.JoinNode`1">
            <summary>
            A JoinNode with a single type argument joins the output of the left side network
            to the right-side network. A single type will only join to the same message that 
            was passed through the left side network to the alpha nodes
            
            BetaMemory is used since it keeps track of all valid activations (joins)
            
            The unjoined messages are discarded (do they need to be kept, will right activations
            ever change, requiring a reevaluation of the join?)
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Stact.Routing.Nodes.SelectiveConsumerNode`1">
            <summary>
            Selectively delivers a message to a consumer on the specified fiber.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Stact.SendExtensions.Send``1(Stact.UntypedChannel)">
            <summary>
              Sends an uninitialized interface implementation
            </summary>
            <typeparam name = "T">The request message type, which must be an interface</typeparam>
            <param name = "channel">The target channel</param>
        </member>
        <member name="T:Stact.Internal.ThreadSingleton`2">
            <summary>
            Encapsulates a value such that only one instance is retained per thread,
            allowing concurrency without blocking on a shared lock for access to a 
            static variable.
            
            NOTE that this is NOT a global variable
            </summary>
            <typeparam name="TContainer">The container type, to ensure proper segregation from other contained types</typeparam>
            <typeparam name="T">The type to contain</typeparam>
        </member>
        <member name="T:Stact.Inbox">
            <summary>
              Mailbox is a higher level construct than a channel, providing channel aggregation,
              directed receives, and dispatching to channels within a context, such as an actor
            </summary>
        </member>
        <member name="M:Stact.Inbox.Receive``1(Stact.SelectiveConsumer{``0})">
            <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
            <typeparam name = "T">The requested message type</typeparam>
            <param name = "consumer">The consumer</param>
        </member>
        <member name="M:Stact.Inbox.Receive``1(Stact.SelectiveConsumer{``0},System.TimeSpan,System.Action)">
            <summary>
              Specifies a method to call when a message is recieved. If a message is not received within
              the specified timeout, a timeout callback is called instead and the receiver is removed from 
              the waiting list of receivers.
            </summary>
            <param name = "consumer">The consumer to call with the message</param>
            <param name = "timeout">The time period to wait for a message</param>
            <param name = "timeoutCallback">The method to call if a message is not received within the timeout period</param>
        </member>
        <member name="T:Stact.Internal.ThreadStaticActorFactory`1">
            <summary>
              Maintains only one instance of an actor per thread
            </summary>
            <typeparam name = "TActor">The actor type</typeparam>
        </member>
        <member name="T:Stact.Configuration.Builders.ConnectionBuilder">
            <summary>
            The root connection builder that is passed through the configurators to build connections
            </summary>
        </member>
        <member name="T:Stact.Configuration.Internal.DistributedInstanceChannelConfiguratorImpl`3">
            <summary>
            Implements the factory that creates the instance channel backed by a 
            KeyedChannelProvider, which maintains an instance of the channel for each
            unique key value
            </summary>
            <typeparam name="TChannel"></typeparam>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TInstance"></typeparam>
        </member>
        <member name="T:Stact.Configuration.FiberProviderConfigurator`2">
            <summary>
              Configures the type of fiber to be used for handling messages
            </summary>
            <typeparam name = "T"></typeparam>
            <typeparam name = "TKey"></typeparam>
        </member>
        <member name="M:Stact.Configuration.FiberProviderConfigurator`2.ShareFiberAcrossInstances">
            <summary>
              Share one fiber for every key value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberProviderConfigurator`2.CreateFiberPerInstance">
            <summary>
              Create a new fiber for each key value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stact.Configuration.FiberProviderConfigurator`2.UseFiberProvider(Stact.FiberProvider{`1})">
            <summary>
              Specifies a specific fiber provider, which provides the fiber for each instance
            </summary>
            <param name = "fiberProvider"></param>
            <returns></returns>
        </member>
        <member name="T:Stact.Configuration.Internal.DistributedInstanceChannelConfigurator`3">
            <summary>
            An instance configuration that is distributed by a specified key
            </summary>
            <typeparam name="TInstance"></typeparam>
            <typeparam name="TChannel"></typeparam>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="M:Stact.ReceiveExtensions.Receive``1(Stact.Inbox,Stact.Consumer{``0})">
            <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
            <typeparam name = "T">The requested message type</typeparam>
            <param name="inbox">The inbox to receive the message from</param>
            <param name = "consumer">The consumer</param>
        </member>
        <member name="M:Stact.ReceiveExtensions.Receive``1(Stact.Inbox,Stact.Consumer{``0},System.TimeSpan,System.Action)">
            <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
            <typeparam name = "T">The requested message type</typeparam>
            <param name="inbox">The inbox to receive the message from</param>
            <param name = "consumer">The consumer</param>
            <param name = "timeout">The time period to wait for a message</param>
            <param name = "timeoutCallback">The method to call if a message is not received within the timeout period</param>
        </member>
        <member name="M:Stact.ReceiveExtensions.Receive``1(Stact.Inbox,Stact.Consumer{``0},System.Int32,System.Action)">
            <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
            <typeparam name = "T">The requested message type</typeparam>
            <param name="inbox">The inbox to receive the message from</param>
            <param name = "consumer">The consumer</param>
            <param name = "timeout">The time period to wait for a message</param>
            <param name = "timeoutCallback">The method to call if a message is not received within the timeout period</param>
        </member>
        <member name="M:Stact.ReceiveExtensions.Receive``1(Stact.Inbox,Stact.SelectiveConsumer{``0},System.Int32,System.Action)">
            <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
            <typeparam name = "T">The requested message type</typeparam>
            <param name="inbox">The inbox to receive the message from</param>
            <param name = "consumer">The consumer</param>
            <param name = "timeout">The time period to wait for a message</param>
            <param name = "timeoutCallback">The method to call if a message is not received within the timeout period</param>
        </member>
        <member name="P:Stact.Response`2.Request">
            <summary>
            The request to which this response is correlated
            </summary>
        </member>
        <member name="T:Stact.Internal.SentRequestImpl`1">
            <summary>
              A decorator for sent requests that enables method chaining
            </summary>
            <typeparam name = "TRequest"></typeparam>
        </member>
        <member name="T:Stact.TypedChannelAdapter`1">
            <summary>
            Converts an untyped channel to a typed channel, passing only messages
            which can be assigned to the channel type and discarding all others
            </summary>
            <typeparam name="TOutput">The output channel type</typeparam>
        </member>
        <member name="T:Stact.Internal.ActorInbox`1">
            <summary>
              An inbox for an actor. Channel properties on the actor are automatically bound.
              Messages are automatically delivered to the inbox for each message type unless
              a property channel has the same message type. Calling Receive on the inbox will
            </summary>
            <typeparam name = "TActor">The actor type for this inbox</typeparam>
        </member>
        <member name="T:Stact.Configuration.Internal.WcfConnectionConfiguratorImpl">
            <summary>
            Exposes the configuration options for a WcfProxy
            </summary>
        </member>
        <member name="T:Stact.InstanceProvider`2">
            <summary>
            Used to obtain and instance of a class based on the information contained
            in the specified message
            </summary>
            <typeparam name="TInstance">The type of the class</typeparam>
            <typeparam name="TChannel">The type of the message</typeparam>
        </member>
        <member name="T:Stact.Internal.AsyncResult">
            <summary>
            A callback-only version of the AsyncResult callback
            </summary>
        </member>
        <member name="T:Stact.ChannelFactory`1">
            <summary>
            Implemented by classes that can create channels. The factory method is used
            to create channels outside of any message delivery context. If the content
            of the message is important in the creation of the channel, the ChannelProvider is a 
            better choice to use since it passes the message as part of the channel acquisition
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Stact.ChannelFactory`1.GetChannel">
            <summary>
            Returns the channel
            </summary>
            <returns>A channel instance</returns>
        </member>
        <member name="T:Stact.Configuration.ChannelConfigurationException">
            <summary>
            Thrown when an invalid configuration is supplied when configuring a channel
            </summary>
        </member>
        <member name="T:Stact.Configuration.Internal.DistinctConfigurator`2">
            <summary>
            Used to configure the options on a channel that delivers messages at regular
            intervals
            </summary>
            <typeparam name="TChannel"></typeparam>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="M:Stact.ExtensionsForConsumerChannel.AddConsumer``1(Stact.Configuration.ConnectionConfigurator{``0},Stact.Consumer{``0})">
            <summary>
            Add a consumer to the channel using the message type defined for the channel
            </summary>
            <typeparam name="TChannel">The channel type, specifies the type of message sent by the channel</typeparam>
            <param name="connectionConfigurator">The connection configurator</param>
            <param name="consumer">The consumer to add to the channel</param>
            <returns>A consumer configurator to customize the consumer settings</returns>
        </member>
        <member name="M:Stact.ExtensionsForConsumerChannel.UsingConsumer``1(Stact.Configuration.ChannelConfigurator{``0},Stact.Consumer{``0})">
            <summary>
            Consumes the message on a ConsumerChannel, given the specified delegate
            </summary>
            <param name="configurator"></param>
            <param name="consumer"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.ExtensionsForIntervalChannels.BufferFor``1(Stact.Configuration.ChannelConfigurator{``0},System.TimeSpan)">
            <summary>
            Specifies an interval at which the consumer should be called with a collection
            of messages received during that period.
            </summary>
            <param name="configurator"></param>
            <param name="interval">The time period of each interval</param>
            <returns></returns>
        </member>
        <member name="M:Stact.ExtensionsForSelectiveConsumerChannel.AddSelectiveConsumer``1(Stact.Configuration.ConnectionConfigurator{``0},Stact.SelectiveConsumer{``0})">
            <summary>
            Add a consumer to the channel using the message type defined for the channel
            </summary>
            <typeparam name="TChannel">The channel type, specifies the type of message sent by the channel</typeparam>
            <param name="connectionConfigurator">The connection configurator</param>
            <param name="consumer">The consumer to add to the channel</param>
            <returns>A consumer configurator to customize the consumer settings</returns>
        </member>
        <member name="M:Stact.ExtensionsForSelectiveConsumerChannel.UsingSelectiveConsumer``1(Stact.Configuration.ChannelConfigurator{``0},Stact.SelectiveConsumer{``0})">
            <summary>
            Consumes the message on a SelectiveConsumerChannel given the specified delegate
            </summary>
            <param name="configurator"></param>
            <param name="selectiveConsumer"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.ExtensionsForAddConsumer.AddConsumerOf``1(Stact.Configuration.ConnectionConfigurator)">
            <summary>
            Add a consumer of the specified message type
            </summary>
            <typeparam name="TChannel">The channel type</typeparam>
            <returns>A chainable method to configure additional options</returns>
        </member>
        <member name="T:Stact.Configuration.Internal.InstanceConfigurator`2">
            <summary>
            A fluent syntax for configuration options of a channel consumer
            </summary>
            <typeparam name="TInstance">The consumer type</typeparam>
            <typeparam name="TChannel">The channel type</typeparam>
        </member>
        <member name="T:Stact.Configuration.Internal.IntervalConfigurator`1">
            <summary>
            Used to configure the options on a channel that delivers messages at regular
            intervals
            </summary>
            <typeparam name="TChannel"></typeparam>
        </member>
        <member name="T:Stact.Configuration.Internal.LastConfigurator`1">
            <summary>
            Used to configure the last channel 
            </summary>
            <typeparam name="TChannel"></typeparam>
        </member>
        <member name="T:Stact.Future`1">
            <summary>
            A future object that supports both callbacks and asynchronous waits once a future value becomes available.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Stact.InstanceChannelProvider`2">
            <summary>
            Gets an instance of a class from the InstanceProvider and returns the channel
            from that class
            </summary>
            <typeparam name="TInstance">The instance type</typeparam>
            <typeparam name="TChannel">The channel type</typeparam>
        </member>
        <member name="T:Stact.SelectiveConsumerChannel`1">
            <summary>
            A channel that accepts a message and enqueues the consumer method via the
            specified Fiber
            </summary>
            <typeparam name="T">The type of message delivered on the channel</typeparam>
        </member>
        <member name="M:Stact.SelectiveConsumerChannel`1.#ctor(Stact.Fiber,Stact.SelectiveConsumer{`0})">
            <summary>
            Constructs a channel
            </summary>
            <param name="fiber">The queue where consumer actions should be enqueued</param>
            <param name="selectiveConsumer">The method to call when a message is sent to the channel</param>
        </member>
        <member name="T:Stact.WcfChannelHost">
            <summary>
            Receives messages from a named pipe via WCF and forwards them to the specific channel. Messages
            are first serialized to a wire type that is already WCF compliant, making it unnecessary to decorate
            your message objects with WCF data contract serializer attributes.
            </summary>
        </member>
        <member name="T:Stact.WcfChannelHost`1">
            <summary>
            Receives messages from a named pipe via WCF and forwards it to the output
            channel. Message serialization is handled entirely by WCF and therefore
            requires that classes are appropriately decorated.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Stact.Configuration.ConnectionConfigurator">
            <summary>
            Used to configure the connections to be added to an UntypedChannel
            </summary>
        </member>
        <member name="T:Stact.ChannelAdapter">
            <summary>
            A channel adapter is a mutable segment in a channel network. The output channel can
            be replaced, allowing a new channel network (built via a ChannelVisitor) to be installed
            in response to changes (attachments, detachments, etc.) to the network.
            
            This particular version handles untyped channels
            </summary>
        </member>
        <member name="T:Stact.ChannelAdapter`1">
            <summary>
            A channel adapter is a mutable segment in a channel network. The output channel can
            be replaced, allowing a new channel network (built via a ChannelVisitor) to be installed
            in response to changes (attachments, detachments, etc.) to the network.
            
            This particular version handles typed channels
            </summary>
        </member>
        <member name="T:Stact.Internal.UntypedChannelConnection">
            <summary>
            The channel connection implementation
            </summary>
        </member>
        <member name="T:Stact.DeserializeMessageEnvelopeChannel`1">
            <summary>
            Accepts a MessageEnvelope as input and deserializes the message body on the supplied fiber,
            after which the message object is sent to the untyped output channel.
            </summary>
            <typeparam name="T">The input message type, which must implement MessageEnvelope</typeparam>
        </member>
        <member name="M:Stact.DeserializeMessageEnvelopeChannel`1.#ctor(Stact.Fiber,Magnum.Serialization.Serializer,Stact.UntypedChannel)">
            <summary>
            Constructs an instance
            </summary>
            <param name="fiber">The fiber used to perform message deserialization</param>
            <param name="serializer">The serializer to use on the message body</param>
            <param name="output">The output channel for the deserialized message</param>
        </member>
        <member name="T:Stact.Internal.WcfChannel`1">
            <summary>
              A single generic channel type used for local channels via WCF/named pipes
            </summary>
            <typeparam name = "T"></typeparam>
        </member>
        <member name="T:Stact.Internal.WcfChannelService`1">
            <summary>
              Handles the server end of a WCF channel connection
            </summary>
            <typeparam name = "T">The channel type</typeparam>
        </member>
        <member name="T:Stact.SelectiveConsumer`1">
            <summary>
              A conditional consumer is given a message to evaluate, after which it
              can determine if it is interested in the message and return an action
              to process the message or null
            </summary>
            <typeparam name = "T">The message type</typeparam>
            <param name = "message">The message</param>
            <returns>An action to consume the message, or null</returns>
        </member>
        <member name="T:Stact.ShuntChannel">
            <summary>
            Implements a channel shunt, discarding any message that is send without action
            </summary>
        </member>
        <member name="T:Stact.ShuntChannel`1">
            <summary>
            Implements a channel shunt, discarding any message that is send without action
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Stact.Routing.RoutingEngine">
            <summary>
            A routing engine managed the distribution of messages to consumers using
            a rules engine style to allow for highly complex routing rules without
            custom application coding
            </summary>
        </member>
        <member name="M:Stact.ExtensionsToScheduler.Schedule(Stact.Scheduler,System.Int32,Stact.Fiber,System.Action)">
            <summary>
            Schedules an operation to be executed after the special interval has elapsed
            </summary>
            <param name="scheduler">The scheduler to reference</param>
            <param name="interval">The duration of the interval</param>
            <param name="fiber">The fiber where the operation should be added</param>
            <param name="operation">The operation to execute</param>
            <returns>A ScheduledOperation reference</returns>
        </member>
        <member name="M:Stact.ExtensionsToScheduler.Schedule(Stact.Scheduler,System.Int32,System.Int32,Stact.Fiber,System.Action)">
            <summary>
            Schedules an operation to be executed after the special interval has elapsed and
            every periodic interval after the initial execution
            </summary>
            <param name="scheduler">The scheduler to reference</param>
            <param name="interval">The duration of the interval</param>
            <param name="periodicInterval">The periodic interval between subsequent executions</param>
            <param name="fiber">The fiber where the operation should be added</param>
            <param name="operation">The operation to execute</param>
            <returns>A ScheduledOperation reference</returns>
        </member>
        <member name="T:Stact.Configuration.FiberConfigurationException">
            <summary>
            Thrown when an invalid configuration is supplied when configuring a channel
            </summary>
        </member>
        <member name="T:Stact.Internal.DisposeCallback">
            <summary>
            Wraps a callback as an IDisposable to allow it to be called when the object is disposed.
            </summary>
        </member>
        <member name="M:Stact.ExtensionsToFiber.ShutdownOnDispose(Stact.Fiber,System.TimeSpan)">
            <summary>
              Creates a disposable object that calls Shutdown on the fiber when it is
              disposed
            </summary>
            <param name = "fiber">The fiber to shutdown</param>
            <param name = "timeout">The timeout to wait for the shutdown to complete</param>
            <returns>An IDisposable object</returns>
        </member>
        <member name="M:Stact.ExtensionsToFiber.StopOnDispose(Stact.Fiber)">
            <summary>
              Creates a disposable object that calls Stop on the fiber when it is
              disposed
            </summary>
            <param name = "fiber">The fiber to stop</param>
            <returns>An IDisposable object</returns>
        </member>
        <member name="M:Stact.ExtensionsToFiber.Shutdown(Stact.Fiber)">
            <summary>
            Signals the fiber to shut down, but does not wait for the remaining operations
            to be executed
            </summary>
            <param name="fiber"></param>
        </member>
        <member name="T:Stact.Internal.KeyedFiberProvider`1">
            <summary>
            Keeps track of a keyed fiber collection
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="T:Stact.FiberProvider`1">
            <summary>
            Returns a fiber appropriate for the specified key
            
            Designed for use with cases where there are multiple channels needed
            for a particular object and the fiber needs to be acquired
            </summary>
            <typeparam name="TKey">The key type</typeparam>
        </member>
        <member name="M:Stact.Fiber.Add(System.Action)">
            <summary>
            Enqueue a single action to the queue
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:Stact.Fiber.Shutdown(System.TimeSpan)">
            <summary>
            Runs all remaining actions, waiting until all actions have been executed or until the
            timeout expires. If the timeout expires, an exception is thrown.
            </summary>
            <param name="timeout">The time to wait for all pending actions to be executed before throwing an exception</param>
        </member>
        <member name="M:Stact.Fiber.Stop">
            <summary>
            Stops the fiber, discards any remaining actions, and prevents new actions from being added
            </summary>
        </member>
        <member name="M:Stact.Scheduler.Schedule(System.TimeSpan,Stact.Fiber,System.Action)">
            <summary>
            Schedules an operation to be executed after the special interval has elapsed
            </summary>
            <param name="interval">The duration of the interval</param>
            <param name="fiber">The fiber where the operation should be added</param>
            <param name="operation">The operation to execute</param>
            <returns>A ScheduledOperation reference</returns>
        </member>
        <member name="M:Stact.Scheduler.Schedule(System.TimeSpan,System.TimeSpan,Stact.Fiber,System.Action)">
            <summary>
            Schedules an operation to be executed after the special interval has elapsed and
            every periodic interval after the initial execution
            </summary>
            <param name="interval">The duration of the interval</param>
            <param name="periodicInterval">The periodic interval between subsequent executions</param>
            <param name="fiber">The fiber where the operation should be added</param>
            <param name="operation">The operation to execute</param>
            <returns>A ScheduledOperation reference</returns>
        </member>
        <member name="M:Stact.Scheduler.Stop(System.TimeSpan)">
            <summary>
            Disables the scheduler, preventing any further scheduled operations from being executed
            </summary>
            <param name="timeout">The time period to wait for the scheduler to shutdown</param>
        </member>
        <member name="M:Stact.ScheduledOperation.Cancel">
            <summary>
              Cancels the scheduled operation, ensuring that it does not execute
            </summary>
        </member>
        <member name="P:Stact.ScheduledOperation.ScheduledAt">
            <summary>
              The time coordinates when the operation is scheduled to execute
            </summary>
        </member>
        <member name="T:Stact.SynchronousFiber">
            <summary>
              A synchronous fiber will execute an action immediately on the calling thread
              without any protection from an exception
            </summary>
        </member>
        <member name="T:Stact.PoolFiber">
            <summary>
            An Fiber that uses the .NET ThreadPool and QueueUserWorkItem to execute
            actions.
            </summary>
        </member>
        <member name="T:Stact.AsyncResultChannel">
            <summary>
            Wraps a channel in an IAsyncResult compatible wrapper to support asynchronous usage with
            frameworks that support asynchronous callbacks
            </summary>
        </member>
        <member name="T:Stact.AsyncResultChannel`1">
            <summary>
            Wraps a channel in an IAsyncResult compatible wrapper to support asynchronous usage with
            frameworks that support asynchronous callbacks
            </summary>
            <typeparam name="T">The channel type supported</typeparam>
        </member>
        <member name="T:Stact.ChannelAccessor`2">
            <summary>
            Provides a channel from an instance
            </summary>
            <typeparam name="TInstance">The type of instance being accessed</typeparam>
            <typeparam name="T">The type of channel to return</typeparam>
            <param name="instance">The instance to retrieve the channel from</param>
            <returns>The channel of the requested type from the instance</returns>
        </member>
        <member name="T:Stact.ConsumerChannel`1">
            <summary>
            A channel that accepts a message and enqueues the consumer method via the
            specified Fiber
            </summary>
            <typeparam name="T">The type of message delivered on the channel</typeparam>
        </member>
        <member name="M:Stact.ConsumerChannel`1.#ctor(Stact.Fiber,Stact.Consumer{`0})">
            <summary>
            Constructs a channel
            </summary>
            <param name="fiber">The queue where consumer actions should be enqueued</param>
            <param name="consumer">The method to call when a message is sent to the channel</param>
        </member>
        <member name="T:Stact.Consumer`1">
            <summary>
            A consumer delegate, which can be assigned to any method that takes a message as an argument,
            including Actions, void methods, etc.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="message"></param>
        </member>
        <member name="T:Stact.DelegateChannelProvider`1">
            <summary>
            Wraps an anonymous method in a ChannelProvider
            </summary>
            <typeparam name="T">The channel type</typeparam>
        </member>
        <member name="M:Stact.Interceptor`1.OnSend(`0)">
            <summary>
            Called before a message is delivered to the output channel
            </summary>
            <param name="message">The message being delivered</param>
            <returns>The message passed, a modified message, or null to discard the message</returns>
        </member>
        <member name="M:Stact.Interceptor`1.OnException(System.Exception)">
            <summary>
            Called when an exception is returned during delivery to the output channel
            </summary>
            <param name="exception">The exception that occurred</param>
        </member>
        <member name="M:Stact.Interceptor`1.OnComplete">
            <summary>
            Called when a message has been successfully delivered to the output channel
            </summary>
        </member>
        <member name="T:Stact.InterceptorChannel`1">
            <summary>
            An interceptor channel can be placed in front of any other channel and provides
            the ability to intercept sends to the wrapper channel and modify the message that
            is sent. An additional method is also called once the message has been processed by
            the wrapped channel
            </summary>
            <typeparam name="T">The channel type</typeparam>
        </member>
        <member name="T:Stact.InterceptorFactory`1">
            <summary>
            Provides an instance of an interceptor for an InterceptorChannel to
            handle the interception of messages on channels
            </summary>
            <typeparam name="T">The message type</typeparam>
        </member>
        <member name="M:Stact.InterceptorFactory`1.GetInterceptor(`0)">
            <summary>
            Returns an instance of an interceptor
            </summary>
            <param name="message">The message being delivered</param>
            <returns>An interceptor</returns>
        </member>
        <member name="T:Stact.DistinctChannel`2">
            <summary>
            A channel that converts a collection of messages into a dictionary of distinct
            messages by the specified key
            </summary>
            <typeparam name="T">The type of message delivered on the channel</typeparam>
            <typeparam name="TKey">The type of the key for the message</typeparam>
        </member>
        <member name="M:Stact.DistinctChannel`2.#ctor(Stact.Fiber,Stact.KeyAccessor{`0,`1},Stact.Channel{System.Collections.Generic.IDictionary{`1,`0}})">
            <summary>
            Constructs a channel
            </summary>
            <param name="fiber">The queue where consumer actions should be enqueued</param>
            <param name="keyAccessor">Returns the key for the message</param>
            <param name="output">The method to call when a message is sent to the channel</param>
        </member>
        <member name="T:Stact.InstanceChannel`1">
            <summary>
            An instance channel requests an instance of a channel which can be created/loaded
            based on the information in the message being sent on the channel
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Stact.Internal.MessageList`1">
            <summary>
            Encapsulates a collection of messages
            </summary>
            <typeparam name="T">The message type</typeparam>
        </member>
        <member name="M:Stact.Internal.MessageList`1.Add(`0)">
            <summary>
            Adds a message to the list
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Stact.Internal.MessageList`1.RemoveAll">
            <summary>
            Removes all messages from the list
            </summary>
            <returns>A list of messages that were removed from the list</returns>
        </member>
        <member name="T:Stact.IntervalChannel`1">
            <summary>
            A channel that accepts messages and sends them to the channel at regular intervals
            </summary>
            <typeparam name="T">The type of message delivered on the channel</typeparam>
        </member>
        <member name="M:Stact.IntervalChannel`1.#ctor(Stact.Fiber,Stact.Scheduler,System.TimeSpan,Stact.Channel{System.Collections.Generic.ICollection{`0}})">
            <summary>
            Constructs a channel
            </summary>
            <param name="fiber">The queue where consumer actions should be enqueued</param>
            <param name="scheduler">The scheduler to use for scheduling calls to the consumer</param>
            <param name="interval">The interval between calls to the consumer</param>
            <param name="output">The method to call when a message is sent to the channel</param>
        </member>
        <member name="T:Stact.KeyAccessor`2">
            <summary>
            Returns the key for the given source
            </summary>
            <typeparam name="T">The type of the source from which the key is to be retrieved</typeparam>
            <typeparam name="TKey">The type of the key to return</typeparam>
            <param name="source">The source from which to retrieve the key</param>
            <returns>The value of the key for the source</returns>
        </member>
        <member name="T:Stact.LastChannel`1">
            <summary>
            Forwards the last message in the set of messages to the next channel
            </summary>
            <typeparam name="T">The type of message delivered on the channel</typeparam>
        </member>
        <member name="T:Stact.FilterChannel`1">
            <summary>
              A channel that selectively accepts a message and enqueues the consumer method via the
              specified Fiber.
              Note that the filter function is called as part of the queued action, so threading
              is not an issue.
            </summary>
            <typeparam name = "T">The type of message delivered on the channel</typeparam>
        </member>
        <member name="M:Stact.FilterChannel`1.#ctor(Stact.Fiber,Stact.Channel{`0},Stact.Filter{`0})">
            <summary>
              Constructs a channel
            </summary>
            <param name = "fiber">The queue where consumer actions should be enqueued</param>
            <param name = "output">The method to call when a message is sent to the channel</param>
            <param name = "filter">The filter to determine if the message can be consumed</param>
        </member>
        <member name="T:Stact.BroadcastChannel">
            <summary>
            A BroadcastChannel sends a message to zero or more listeners
            </summary>
        </member>
        <member name="T:Stact.BroadcastChannel`1">
            <summary>
            A BroadcastChannel sends a message to zero or more listeners
            </summary>
            <typeparam name = "T">Channel type</typeparam>
        </member>
        <member name="T:Stact.SynchronizedChannel">
            <summary>
            Using the specified SynchronizationContext, messages sent through this channel
            will be delivered on the specified user interface thread, to avoid issues when
            writing to the UI
            </summary>
        </member>
        <member name="T:Stact.SynchronizedChannel`1">
            <summary>
            Using the specified SynchronizationContext, messages sent through this channel
            will be delivered on the specified user interface thread, to avoid issues when
            writing to the UI
            </summary>
            <typeparam name="T">The channel type</typeparam>
        </member>
        <member name="T:Stact.ThreadPoolChannel`1">
            <summary>
            Keeps a fixed number of channels available, which presumably are doing some form of synchronous processing
            of messages, to avoid too many consumers running at the same time
            </summary>
            <typeparam name="T">The channel type</typeparam>
        </member>
        <member name="T:Stact.ThreadStaticChannelProvider`1">
            <summary>
            Provides an instance of a channel per thread for situations where the
            processing of a channel should be done per-thread to avoid bottlenecks
            
            This should not be used in cases where the channel maintains state
            between calls since threads may change and ordering cannot be guaranteed
            </summary>
            <typeparam name="T">The message type of the channel</typeparam>
        </member>
        <member name="T:Stact.ConvertChannel`2">
            <summary>
              Tranforms a message from one type to another
            </summary>
            <typeparam name = "TInput">Input message type</typeparam>
            <typeparam name = "TOutput">Output message type</typeparam>
        </member>
        <member name="T:Stact.StateMachine.ChannelConfiguration.CacheChannelProvider`2">
            <summary>
            Gets an instance of a class from the InstanceProvider and returns the channel
            from that class
            </summary>
            <typeparam name="TChannel">The channel type</typeparam>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="T:Stact.InstanceChannelPolicy`2">
            <summary>
            Defines the instance policy for a regarding a particular event
            </summary>
            <typeparam name="T">The state machine type</typeparam>
            <typeparam name="TChannel">The channel type</typeparam>
        </member>
        <member name="M:Stact.InstanceChannelPolicy`2.CanCreateInstance(`1,`0@)">
            <summary>
            Returns true if the message can create a new instance
            </summary>
            <param name="message">The message received</param>
            <param name="instance">The instance created</param>
            <returns>True if the new instance could be created</returns>
        </member>
        <member name="M:Stact.InstanceChannelPolicy`2.IsHandledByExistingInstance(`1)">
            <summary>
            Checks if the message can be handled by an existing instance
            </summary>
            <param name="message">The message received</param>
            <returns>True if the message should be delivered to the instance, otherwise false</returns>
        </member>
        <member name="M:Stact.InstanceChannelPolicy`2.WasNotHandled(`1)">
            <summary>
            Called when a message was not handled by an instance
            </summary>
            <param name="message">The message that was not handled</param>
        </member>
        <member name="M:Stact.InstanceChannelPolicy`2.CanUnloadInstance(`0)">
            <summary>
            Checks if an instance can be unloaded
            </summary>
            <param name="instance">The instance to check</param>
            <returns>True if the instance can be unloaded from memory</returns>
        </member>
        <member name="M:Stact.InstanceChannelPolicy`2.CanRemoveInstance(`0)">
            <summary>
            Checks if an instance can be removed/destroyed
            </summary>
            <param name="instance">The instance to check</param>
            <returns>True if the instance can be removed from storage</returns>
        </member>
        <member name="T:Stact.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2">
            <summary>
            Describes an event, received by a state machine, and the in which that event is valid
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Stact.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2.Event">
            <summary>
            The event received by the state machine
            </summary>
        </member>
        <member name="P:Stact.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2.AcceptingStates">
            <summary>
            The states in which the event can be delivered to the state machine
            </summary>
        </member>
        <member name="T:Stact.Workflow.Internal.AcceptStateMachineVisitor">
            <summary>
            Implemented by objects that accept a StateMachineVisitor for discovery
            </summary>
        </member>
        <member name="T:Stact.Workflow.StateMachineWorkflow`2">
            <summary>
            A state machine workflow encapsulates the definition of a state machine behind a 
            workflow interface. The interface can be used to apply the state machine behavior
            to a class instance. It can also be visited to graph the state machineb behavior 
            for user review.
            </summary>
            <typeparam name="TWorkflow">The interface that defines the states and events for the workflow</typeparam>
            <typeparam name="TInstance">The instance that is used to track the state</typeparam>
        </member>
        <member name="T:Stact.Workflow.WorkflowDefinition">
            <summary>
            Exposes the metadata of a state machine workflow
            </summary>
        </member>
        <member name="M:Stact.Workflow.WorkflowDefinition.GetState(System.String)">
            <summary>
            Retrieves the named state for the state machine workflow
            </summary>
            <param name="name">The name of the state</param>
            <returns>The configured State</returns>
        </member>
        <member name="M:Stact.Workflow.WorkflowDefinition.GetEvent(System.String)">
            <summary>
            Retrieves the named event for the state machine workflow
            </summary>
            <param name="name">The name of the event</param>
            <returns>The Event</returns>
        </member>
        <member name="P:Stact.Workflow.State.Entry">
            <summary>
            Triggered when the state becomes the current state
            </summary>
        </member>
        <member name="P:Stact.Workflow.State.Exit">
            <summary>
            Triggered when the instance is transitioned to another state
            </summary>
        </member>
        <member name="M:Stact.Workflow.ThenExtensions.Then``2(Stact.Workflow.Configuration.ActivityConfigurator{``0,``1},System.Action{``1})">
            <summary>
            Invoke an action with the state machine instance
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <param name="activityConfigurator"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.ThenExtensions.Then``3(Stact.Workflow.Configuration.ActivityConfigurator{``0,``1,``2},System.Action{``1,``2})">
            <summary>
            Invoke an action with the state machine instance and the body of the message event
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <typeparam name="TBody"></typeparam>
            <param name="activityConfigurator"></param>
            <param name="eventAction"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.During``2(Stact.Workflow.Configuration.StateMachineConfigurator{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,Stact.Workflow.State}})">
            <summary>
            Selects a state to which events can be added
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <param name="stateMachineConfigurator"></param>
            <param name="stateExpression"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.Initially``2(Stact.Workflow.Configuration.StateMachineConfigurator{``0,``1})">
            <summary>
            The initial state for a workflow (named Initial) to which events can be attached
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <param name="stateMachineConfigurator"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.Finally``2(Stact.Workflow.Configuration.StateMachineConfigurator{``0,``1})">
            <summary>
            Finally is triggered upon entry to the Final state
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <param name="stateMachineConfigurator"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.Finally``2(Stact.Workflow.Configuration.StateMachineConfigurator{``0,``1},System.Action{Stact.Workflow.Configuration.ActivityConfigurator{``0,``1}})">
            <summary>
            Finally is triggered upon entry to the Final state
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <param name="stateMachineConfigurator"></param>
            <param name="configurationAction"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.When``2(Stact.Workflow.Configuration.StateConfigurator{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,Stact.Workflow.Event}})">
            <summary>
            Selects an event that is accepted during the specified state
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <param name="stateConfigurator"></param>
            <param name="eventExpression"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.When``3(Stact.Workflow.Configuration.StateConfigurator{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,Stact.Workflow.Event{``2}}})">
            <summary>
            Selects an event that is accepted during the specified state
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <typeparam name="TBody"></typeparam>
            <param name="stateConfigurator"></param>
            <param name="eventExpression"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.StateMachineConfiguratorExtensions.Finalize``2(Stact.Workflow.Configuration.ActivityConfigurator{``0,``1})">
            <summary>
            Transition the state machine workflow to the Final state
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <param name="activityConfigurator"></param>
            <returns></returns>
        </member>
        <member name="P:Stact.Workflow.WorkflowInstance`1.CurrentState">
            <summary>
            Returns the current state for the instance
            </summary>
        </member>
        <member name="M:Stact.Workflow.TransitionToExtensions.TransitionTo``2(Stact.Workflow.Configuration.ActivityConfigurator{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,Stact.Workflow.State}})">
            <summary>
            Transition the state machine to the specified state
            </summary>
            <typeparam name="TWorkflow"></typeparam>
            <typeparam name="TInstance"></typeparam>
            <param name="activityConfigurator"></param>
            <param name="targetStateExpression"></param>
            <returns></returns>
        </member>
        <member name="M:Stact.Workflow.WorkflowInstanceExtensions.GetInstance``2(Stact.Workflow.StateMachineWorkflow{``0,``1},``1)">
            <summary>
            Wraps an instance so that it can be passed without the TInstance dependency
            </summary>
            <param name="workflow">The workflow</param>
            <param name="instance">The instance to wrap</param>
            <returns></returns>
        </member>
    </members>
</doc>
